// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Draw
#pragma kernel Clear
#pragma kernel Erase
#pragma kernel Random
#pragma kernel Coat
#pragma kernel Count

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct ColorCountStruct
{
    int Red;
    int Green;
    int Blue;
    int Yellow;
    int Cyan;
    int Magenta;
    int White;
};

RWStructuredBuffer<ColorCountStruct> ColorCountBuffer;
RWTexture2D<float4> DrawTexture;
RWTexture2D<float4> CoatTexture;

// Color used for Drawing
float4 color = float4(1,1,1,1);
// Coordinate of Drawing position
float2 uv;
// Scale of a surface
float2 scale;
// Radius of a Drawing
float radius = 0.1f;
// Number of chunks per 1m
int resolution = 100;

// Noise related settings
float noiseTime     = 0.0f;
int noiseSeed       = 0;
float2 noiseScale   = float2(1.0, 1.0);
float2 noiseOffset  = float2(1.0, 1.0);

// ############# Colors ################

static const int RedBit     = 1 << 0;
static const int GreenBit   = 1 << 1;
static const int BlueBit    = 1 << 2;
static const int YellowBit  = RedBit | GreenBit;
static const int MagentaBit = RedBit | BlueBit;
static const int CyanBit    = GreenBit | BlueBit;
static const int WhiteBit   = RedBit | GreenBit | BlueBit;

static const float4 Red     = float4(1.0, 0.0, 0.0, 1.0);
static const float4 Green   = float4(0.0, 1.0, 0.0, 1.0);
static const float4 Blue    = float4(0.0, 0.0, 1.0, 1.0);
static const float4 Yellow  = float4(1.0, 1.0, 0.0, 1.0);
static const float4 Magenta = float4(1.0, 0.0, 1.0, 1.0);
static const float4 Cyan    = float4(0.0, 1.0, 1.0, 1.0);
static const float4 White   = float4(1.0, 1.0, 1.0, 1.0);

// ############# Helpers ################

int ToColCode(in float4 col)
{
    int colCode = 0;
    if(col.r == 1.0) colCode |= 1;
    if(col.g == 1.0) colCode |= 2;
    if(col.b == 1.0) colCode |= 4;
    return colCode;
}

void DecrementColor(in float4 col)
{
    int colCode = ToColCode(col);
    switch(colCode)
    {
        case RedBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Red, -1);
            break;
        }
        case GreenBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Green, -1);
            break;
        }
        case BlueBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Blue, -1);
            break;
        }
        case YellowBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Yellow, -1);
            break;
        }
        case MagentaBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Magenta, -1);
            break;
        }
        case CyanBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Cyan, -1);
            break;
        }
        case WhiteBit:
        {
            InterlockedAdd(ColorCountBuffer[0].White, -1);
            break;
        }
    }
}

void IncrementColor(in float4 col)
{
    int colCode = ToColCode(col);
    switch(colCode)
    {
        case RedBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Red, 1);
            break;
        }
        case GreenBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Green, 1);
            break;
        }
        case BlueBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Blue, 1);
            break;
        }
        case YellowBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Yellow, 1);
            break;
        }
        case MagentaBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Magenta, 1);
            break;
        }
        case CyanBit:
        {
            InterlockedAdd(ColorCountBuffer[0].Cyan, 1);
            break;
        }
        case WhiteBit:
        {
            InterlockedAdd(ColorCountBuffer[0].White, 1);
            break;
        }
    }
}

// ############# Noise ################

float2 grad( int2 z )  // replace this anything that returns a random vector
{
    // 2D to 1D  (feel free to replace by some other)
    int n = z.x+z.y*11111;

    // Hugo Elias hash (feel free to replace by another one)
    n = (n<<13)^n;
    n = (n*(n*n*15731+789221)+1376312589)>>16;

    // Perlin style vectors
    n &= 7;
    float2 gr = float2(n&1,n>>1)*2.0-1.0;
    return ( n>=6 ) ? float2(0.0,gr.x) : 
           ( n>=4 ) ? float2(gr.x,0.0) :
                              gr;
}

float noise( in float2 p )
{
    int2 i = int2(floor( p ));
    float2 f =       frac( p );
	
	float2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead

    return lerp( lerp( dot( grad( i+int2(0,0) ), f-float2(0.0,0.0) ), 
                     dot( grad( i+int2(1,0) ), f-float2(1.0,0.0) ), u.x),
                lerp( dot( grad( i+int2(0,1) ), f-float2(0.0,1.0) ), 
                     dot( grad( i+int2(1,1) ), f-float2(1.0,1.0) ), u.x), u.y);
}

// ############# Kernels ################

// BIG TODO: Make color counter a indenpendent kernel

// 32x16 | 32x16 | 1x1 -> Good for 400
// 32x32 | 32x32 | 1x1 -> Good for 1000

// id = uv * scale * resolution

// Stores 'color' on a DrawTexture within a radius and atomically increments/decrements color count
[numthreads(32,32,1)]
void Draw(uint3 id : SV_DispatchThreadID)
{
    // Return if thread is outside of working domain
    if
    (
        id.x >= (uint)(scale.x * resolution) ||
        id.y >= (uint)(scale.y * resolution)
    ) return;

    // Local Position of a texel
    float2 pos = uv * scale;

    // Local Position of a thread
    float2 curr = (float2)id.xy / resolution;

    // Update result
    float4 currColor = DrawTexture[id.xy];
    if(distance(curr, pos) <= radius)
    {
        currColor = color;
    }
    DrawTexture[id.xy] = currColor;
};

// Additively stores 'color' in CoatTexture and atomically decrements colors in that area
[numthreads(32,32,1)]
void Coat(uint3 id : SV_DispatchThreadID)
{
    // Return if thread is outside of working domain
    if
    (
        id.x >= (uint)(scale.x * resolution) ||
        id.y >= (uint)(scale.y * resolution)
    ) return;

    // Local Position of a texel
    float2 pos = uv * scale;

    // Local Position of a thread
    float2 curr = (float2)id.xy / resolution;

    // Update result
    float4 currColor = CoatTexture[id.xy];
    if(distance(curr, pos) <= radius)
    {
        currColor.r = max(currColor.r, color.r);
        currColor.g = max(currColor.g, color.g);
        currColor.b = max(currColor.b, color.b);
    }
    CoatTexture[id.xy] = currColor;
};

// Stores 'clearColor' on a whole DrawTexture
[numthreads(32,32,1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    // Return if thread is outside of working domain
    if
    (
        id.x >= (uint)(scale.x * resolution) ||
        id.y >= (uint)(scale.y * resolution)
    ) return;

    DrawTexture[id.xy] = float4(0, 0, 0, 0);
    CoatTexture[id.xy] = float4(0, 0, 0, 0);
};

// Similar to Clear but works only in a radius of a spot
[numthreads(32,32,1)]
void Erase(uint3 id : SV_DispatchThreadID)
{
    // Return if thread is outside of working domain
    if
    (
        id.x >= (uint)(scale.x * resolution) ||
        id.y >= (uint)(scale.y * resolution)
    ) return;

    // Local Position of a texel
    float2 pos = uv * scale;

    // Local Position of a thread
    float2 curr = (float2)id.xy / resolution;

    // Update result
    float4 currColor = DrawTexture[id.xy];
    if(distance(curr, pos) <= radius)
    {
        currColor = float4(0, 0, 0, 0);
    }
    DrawTexture[id.xy] = currColor;
};

// Stores random value into DrawTexture depending on noise
// TODO Change to color coat?
[numthreads(32,32,1)]
void Random(uint3 id : SV_DispatchThreadID)
{
    // Return if thread is outside of working domain
    if
    (
        id.x >= (uint)(scale.x * resolution) ||
        id.y >= (uint)(scale.y * resolution)
    ) return;

    // Local Position of a thread
    float2 curr = (float2)id.xy / resolution;

    float val = noise((curr + noiseOffset) * noiseScale);

    float4 currColor = DrawTexture[id.xy];

    if(val < 0.33)
    {
        currColor = Red;
    }
    else if(val < 0.66)
    {
        currColor = Green;
    }
    else
    {
        currColor = Blue;
    }

    DrawTexture[id.xy] = currColor;
}

// Counts all colors on this DrawTexture, taking coat in account
[numthreads(32,32,1)]
void Count(uint3 id : SV_DispatchThreadID)
{
    // Return if thread is outside of working domain
    if
    (
        id.x >= (uint)(scale.x * resolution) ||
        id.y >= (uint)(scale.y * resolution)
    ) return;

    // Update result
    float4 currColor = DrawTexture[id.xy];
    float4 coat = CoatTexture[id.xy];

    // Turn absorbing colors to 0 and ok colors to 1
    coat *= float4(-1, -1, -1, -1);
    coat += float4(1, 1, 1, 1);
    
    currColor *= coat;

    IncrementColor(currColor);
};